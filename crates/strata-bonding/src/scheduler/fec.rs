//! Forward Error Correction (FEC) with Unequal Error Protection (UEP).
//!
//! Uses RaptorQ (RFC 6330) fountain codes to generate repair symbols for
//! outgoing packet groups.  Packets are classified into [`ProtectionLevel`]s
//! that determine the amount of FEC overhead applied:
//!
//! - **High** — critical /  I-frame data: 50 % overhead (2:1 ratio).
//! - **Low** — P/B-frame / droppable data: 10 % overhead (10:1 ratio).
//! - **None** — no FEC applied (raw passthrough).
//!
//! The sender groups packets into *source blocks* of configurable depth,
//! then emits repair symbols that the receiver can use to reconstruct
//! any missing source packets from the block.
//!
//! A two-state **Gilbert–Elliott** model per link estimates the current
//! channel loss regime (Good vs Bad) and can be used to dynamically
//! adjust FEC overhead at runtime.

use bytes::{Bytes, BytesMut};
use raptorq::{Decoder, Encoder, EncodingPacket, ObjectTransmissionInformation};

/// Maximum transfer unit (bytes) used as the RaptorQ symbol size.
const SYMBOL_SIZE: u16 = 1400;

/// FEC protection level for a packet or source block.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProtectionLevel {
    /// High protection: 50 % repair overhead (critical / I-frame).
    High,
    /// Low protection: 10 % repair overhead (P/B-frame).
    Low,
    /// No FEC — raw passthrough.
    None,
}

impl ProtectionLevel {
    /// Returns the number of extra repair symbols to generate per source
    /// symbol.  For example 0.5 → generate 50 % as many repair symbols
    /// as source symbols.
    pub fn overhead_ratio(self) -> f64 {
        match self {
            ProtectionLevel::High => 0.50,
            ProtectionLevel::Low => 0.10,
            ProtectionLevel::None => 0.0,
        }
    }
}

/// Configuration for the FEC encoder.
#[derive(Debug, Clone)]
pub struct FecConfig {
    /// Enable FEC encoding.
    pub enabled: bool,
    /// Number of source packets to group into one source block before
    /// emitting repair symbols.  Larger blocks yield better erasure
    /// correction efficiency but increase latency.
    pub source_block_size: usize,
    /// Override overhead ratio for High protection (0.0 – 1.0).
    pub high_overhead: f64,
    /// Override overhead ratio for Low protection (0.0 – 1.0).
    pub low_overhead: f64,
}

impl Default for FecConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            source_block_size: 8,
            high_overhead: 0.50,
            low_overhead: 0.10,
        }
    }
}

/// Packet payload annotated with FEC metadata for the sender.
#[derive(Debug, Clone)]
pub struct FecSourcePacket {
    /// The original payload.
    pub payload: Bytes,
    /// FEC source block ID (groups packets for recovery).
    pub block_id: u32,
    /// Index within the source block.
    pub symbol_idx: u16,
}

/// A repair symbol generated by the FEC encoder.
#[derive(Debug, Clone)]
pub struct RepairSymbol {
    /// FEC source block ID this repair symbol belongs to.
    pub block_id: u32,
    /// Serialized RaptorQ encoding packet.
    pub data: Bytes,
}

/// Accumulates source packets into blocks and generates repair symbols.
pub struct FecEncoder {
    config: FecConfig,
    /// Current source block accumulator.
    current_block: Vec<Bytes>,
    /// Monotonic block ID counter.
    next_block_id: u32,
    /// Protection level for the current block.
    current_level: ProtectionLevel,
}

impl FecEncoder {
    /// Create a new encoder with the given configuration.
    pub fn new(config: FecConfig) -> Self {
        Self {
            config,
            current_block: Vec::new(),
            next_block_id: 0,
            current_level: ProtectionLevel::None,
        }
    }

    /// Returns true if FEC encoding is enabled.
    pub fn is_enabled(&self) -> bool {
        self.config.enabled
    }

    /// Dynamically update FEC overhead ratios based on available spare bandwidth.
    ///
    /// Called by the stats/adaptation loop when the BitrateAdapter computes
    /// a new `recommended_fec_overhead`. Both High and Low protection scale
    /// relative to the recommended value:
    /// - High = recommended × 2.5 (capped at 1.0)
    /// - Low = recommended (10–50% range)
    pub fn set_overheads(&mut self, recommended: f64) {
        let recommended = recommended.clamp(0.0, 1.0);
        self.config.low_overhead = recommended;
        self.config.high_overhead = (recommended * 2.5).min(1.0);
    }

    /// Add a source packet.  Returns any repair symbols if a complete
    /// source block has been assembled.
    pub fn push(&mut self, payload: Bytes, level: ProtectionLevel) -> Vec<RepairSymbol> {
        if !self.config.enabled || level == ProtectionLevel::None {
            return Vec::new();
        }

        // If protection level changed mid-block, flush the old block first.
        if !self.current_block.is_empty() && level != self.current_level {
            let repairs = self.flush();
            self.current_level = level;
            self.current_block.push(payload);
            return repairs;
        }

        self.current_level = level;
        self.current_block.push(payload);

        if self.current_block.len() >= self.config.source_block_size {
            self.flush()
        } else {
            Vec::new()
        }
    }

    /// Flush the current (possibly partial) source block and emit repair
    /// symbols.  Call this at end-of-stream or protection-level boundaries.
    pub fn flush(&mut self) -> Vec<RepairSymbol> {
        if self.current_block.is_empty() {
            return Vec::new();
        }

        let block_id = self.next_block_id;
        self.next_block_id = self.next_block_id.wrapping_add(1);

        let overhead = match self.current_level {
            ProtectionLevel::High => self.config.high_overhead,
            ProtectionLevel::Low => self.config.low_overhead,
            ProtectionLevel::None => return Vec::new(),
        };

        // Concatenate source packets into a single data blob for RaptorQ.
        let mut combined = BytesMut::new();
        for pkt in &self.current_block {
            // Length-prefix each packet so the decoder can split them.
            combined.extend_from_slice(&(pkt.len() as u32).to_be_bytes());
            combined.extend_from_slice(pkt);
        }
        let data = combined.freeze();

        let num_source_symbols = (data.len() as f64 / SYMBOL_SIZE as f64).ceil() as u32;
        let num_repair = ((num_source_symbols as f64) * overhead).ceil() as u32;

        if num_repair == 0 {
            self.current_block.clear();
            return Vec::new();
        }

        let encoder = Encoder::with_defaults(&data, SYMBOL_SIZE);
        let repair_packets: Vec<EncodingPacket> = encoder.get_encoded_packets(num_repair);

        let repairs = repair_packets
            .into_iter()
            .map(|ep| {
                let serialized = ep.serialize();
                RepairSymbol {
                    block_id,
                    data: Bytes::from(serialized),
                }
            })
            .collect();

        self.current_block.clear();
        repairs
    }

    /// Returns the number of repair symbols generated so far (block count).
    pub fn blocks_emitted(&self) -> u32 {
        self.next_block_id
    }
}

/// Receiver-side FEC decoder for a single source block.
pub struct FecBlockDecoder {
    /// Total data length expected for this block.
    transfer_info: ObjectTransmissionInformation,
    decoder: Decoder,
    /// Number of source + repair packets received so far.
    received_count: usize,
}

impl FecBlockDecoder {
    /// Create a decoder for a source block with the given data length.
    pub fn new(data_len: u64) -> Self {
        let oti = ObjectTransmissionInformation::with_defaults(data_len, SYMBOL_SIZE);
        Self {
            transfer_info: oti,
            decoder: Decoder::new(oti),
            received_count: 0,
        }
    }

    /// Returns the OTI for this block.
    pub fn transfer_info(&self) -> &ObjectTransmissionInformation {
        &self.transfer_info
    }

    /// Feed an encoding packet (source or repair) into the decoder.
    /// Returns `Some(data)` if the block can now be fully reconstructed.
    pub fn add_packet(&mut self, serialized: &[u8]) -> Option<Bytes> {
        self.received_count += 1;
        let ep = EncodingPacket::deserialize(serialized);
        self.decoder.decode(ep).map(Bytes::from)
    }

    /// Number of packets received so far.
    pub fn received(&self) -> usize {
        self.received_count
    }
}

/// Splits a decoded source block back into individual packets.
pub fn split_source_block(data: &[u8]) -> Vec<Bytes> {
    let mut out = Vec::new();
    let mut offset = 0;
    while offset + 4 <= data.len() {
        let len = u32::from_be_bytes([
            data[offset],
            data[offset + 1],
            data[offset + 2],
            data[offset + 3],
        ]) as usize;
        offset += 4;
        if offset + len > data.len() {
            break;
        }
        out.push(Bytes::copy_from_slice(&data[offset..offset + len]));
        offset += len;
    }
    out
}

// ────────────────────────────────────────────────────────────────
// Gilbert–Elliott two-state loss model
// ────────────────────────────────────────────────────────────────

/// Two-state Gilbert–Elliott channel model for estimating burst loss.
///
/// Tracks per-link loss state as either **Good** (low loss) or **Bad**
/// (high / burst loss).  The model transitions between states based on
/// consecutive packet outcomes.
///
/// Used to dynamically raise FEC overhead when a link enters the Bad
/// state (burst loss regime).
#[derive(Debug, Clone)]
pub struct GilbertElliott {
    /// Current state: true = Bad (burst loss), false = Good.
    in_bad_state: bool,
    /// Consecutive good (received) packets in current epoch.
    good_run: u32,
    /// Consecutive bad (lost) packets in current epoch.
    bad_run: u32,
    /// Threshold of consecutive losses to transition Good → Bad.
    loss_threshold: u32,
    /// Threshold of consecutive receives to transition Bad → Good.
    recovery_threshold: u32,
}

impl GilbertElliott {
    /// Create a new model with default thresholds.
    pub fn new() -> Self {
        Self {
            in_bad_state: false,
            good_run: 0,
            bad_run: 0,
            loss_threshold: 3,
            recovery_threshold: 10,
        }
    }

    /// Create a model with custom thresholds.
    pub fn with_thresholds(loss_threshold: u32, recovery_threshold: u32) -> Self {
        Self {
            in_bad_state: false,
            good_run: 0,
            bad_run: 0,
            loss_threshold: loss_threshold.max(1),
            recovery_threshold: recovery_threshold.max(1),
        }
    }

    /// Record a packet outcome: `true` = received, `false` = lost.
    pub fn observe(&mut self, received: bool) {
        if received {
            self.good_run += 1;
            self.bad_run = 0;
            if self.in_bad_state && self.good_run >= self.recovery_threshold {
                self.in_bad_state = false;
            }
        } else {
            self.bad_run += 1;
            self.good_run = 0;
            if !self.in_bad_state && self.bad_run >= self.loss_threshold {
                self.in_bad_state = true;
            }
        }
    }

    /// Returns true if the channel is currently in the Bad (burst loss) state.
    pub fn is_bad(&self) -> bool {
        self.in_bad_state
    }

    /// Suggested FEC multiplier: 1.0 in Good state, higher in Bad state.
    pub fn fec_multiplier(&self) -> f64 {
        if self.in_bad_state {
            2.0
        } else {
            1.0
        }
    }
}

impl Default for GilbertElliott {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn encoder_produces_repair_symbols_high() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 4,
            high_overhead: 0.50,
            low_overhead: 0.10,
        };
        let mut enc = FecEncoder::new(cfg);

        // Push 4 packets of ~200 bytes each → triggers flush
        let mut repairs = Vec::new();
        for i in 0..4 {
            let payload = Bytes::from(vec![i as u8; 200]);
            repairs.extend(enc.push(payload, ProtectionLevel::High));
        }

        assert!(
            !repairs.is_empty(),
            "High protection should produce repair symbols"
        );
        assert_eq!(enc.blocks_emitted(), 1);
    }

    #[test]
    fn encoder_no_repair_when_disabled() {
        let cfg = FecConfig {
            enabled: false,
            ..FecConfig::default()
        };
        let mut enc = FecEncoder::new(cfg);
        let repairs = enc.push(Bytes::from_static(b"data"), ProtectionLevel::High);
        assert!(repairs.is_empty());
        assert_eq!(enc.blocks_emitted(), 0);
    }

    #[test]
    fn encoder_no_repair_for_none_level() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 2,
            ..FecConfig::default()
        };
        let mut enc = FecEncoder::new(cfg);
        let r1 = enc.push(Bytes::from_static(b"a"), ProtectionLevel::None);
        let r2 = enc.push(Bytes::from_static(b"b"), ProtectionLevel::None);
        assert!(r1.is_empty());
        assert!(r2.is_empty());
    }

    #[test]
    fn encoder_flush_partial_block() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 8,
            high_overhead: 0.50,
            ..FecConfig::default()
        };
        let mut enc = FecEncoder::new(cfg);
        // Push only 3 packets (block size is 8)
        for i in 0..3 {
            enc.push(Bytes::from(vec![i; 300]), ProtectionLevel::High);
        }
        let repairs = enc.flush();
        assert!(
            !repairs.is_empty(),
            "Flush of partial block should produce repair symbols"
        );
        assert_eq!(enc.blocks_emitted(), 1);
    }

    #[test]
    fn encode_decode_roundtrip() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 4,
            high_overhead: 0.50,
            ..FecConfig::default()
        };
        let mut enc = FecEncoder::new(cfg);

        let payloads: Vec<Bytes> = (0..4).map(|i| Bytes::from(vec![i as u8; 200])).collect();

        // Generate encoded source block + repair symbols
        let mut all_repairs = Vec::new();
        for p in &payloads {
            all_repairs.extend(enc.push(p.clone(), ProtectionLevel::High));
        }
        assert!(!all_repairs.is_empty());

        // To decode, we need the encoder's source block output.
        // Re-encode to get all encoding packets (source + repair).
        let mut combined = BytesMut::new();
        for p in &payloads {
            combined.extend_from_slice(&(p.len() as u32).to_be_bytes());
            combined.extend_from_slice(p);
        }
        let data = combined.freeze();

        let encoder = Encoder::with_defaults(&data, SYMBOL_SIZE);
        let source_packets = encoder.get_encoded_packets(0);
        let repair_packets = encoder.get_encoded_packets(2);

        // Feed all source packets into decoder
        let mut decoder = FecBlockDecoder::new(data.len() as u64);
        for sp in &source_packets {
            let serialized = sp.serialize();
            if let Some(recovered) = decoder.add_packet(&serialized) {
                assert_eq!(recovered, data);
                let split = split_source_block(&recovered);
                assert_eq!(split.len(), 4);
                for (i, p) in split.iter().enumerate() {
                    assert_eq!(*p, payloads[i]);
                }
                return;
            }
        }

        // If source packets alone didn't suffice, feed repair
        for rp in &repair_packets {
            let serialized = rp.serialize();
            if let Some(recovered) = decoder.add_packet(&serialized) {
                let split = split_source_block(&recovered);
                assert_eq!(split.len(), 4);
                return;
            }
        }

        // Should have decoded by now
        panic!("Failed to decode source block");
    }

    #[test]
    fn decode_with_erasure() {
        // Encode 4 packets, drop 1 source, recover from repair
        let payloads: Vec<Bytes> = (0..4)
            .map(|i| Bytes::from(vec![i as u8 + 10; 300]))
            .collect();

        let mut combined = BytesMut::new();
        for p in &payloads {
            combined.extend_from_slice(&(p.len() as u32).to_be_bytes());
            combined.extend_from_slice(p);
        }
        let data = combined.freeze();

        let encoder = Encoder::with_defaults(&data, SYMBOL_SIZE);
        let source_packets = encoder.get_encoded_packets(0);
        // Generate enough repair to cover 1 erasure
        let repair_packets = encoder.get_encoded_packets(2);

        let mut decoder = FecBlockDecoder::new(data.len() as u64);

        // Feed all source packets EXCEPT the first one (simulate erasure)
        for sp in source_packets.iter().skip(1) {
            let serialized = sp.serialize();
            decoder.add_packet(&serialized);
        }

        // Feed repair packets until recovery
        let mut recovered = false;
        for rp in &repair_packets {
            let serialized = rp.serialize();
            if let Some(result) = decoder.add_packet(&serialized) {
                let split = split_source_block(&result);
                assert_eq!(split.len(), 4, "Should recover all 4 packets");
                assert_eq!(split[0], payloads[0], "First packet should be recovered");
                recovered = true;
                break;
            }
        }
        assert!(
            recovered,
            "Should recover from 1 erasure with 2 repair symbols"
        );
    }

    #[test]
    fn uep_high_produces_more_repair_than_low() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 4,
            high_overhead: 0.50,
            low_overhead: 0.10,
        };

        // Use large payloads so that the source symbol count is high enough
        // for the overhead ratios to produce visibly different repair counts.
        let pkt_size = 3000;

        // High protection block
        let mut enc_high = FecEncoder::new(cfg.clone());
        let mut high_repairs = Vec::new();
        for i in 0..4 {
            high_repairs
                .extend(enc_high.push(Bytes::from(vec![i; pkt_size]), ProtectionLevel::High));
        }

        // Low protection block
        let mut enc_low = FecEncoder::new(cfg);
        let mut low_repairs = Vec::new();
        for i in 0..4 {
            low_repairs.extend(enc_low.push(Bytes::from(vec![i; pkt_size]), ProtectionLevel::Low));
        }

        assert!(
            high_repairs.len() > low_repairs.len(),
            "High protection ({} repairs) should produce more repair than Low ({} repairs)",
            high_repairs.len(),
            low_repairs.len()
        );
    }

    #[test]
    fn split_source_block_roundtrip() {
        let packets = vec![
            Bytes::from_static(b"hello"),
            Bytes::from_static(b"world"),
            Bytes::from_static(b"!"),
        ];

        let mut combined = BytesMut::new();
        for p in &packets {
            combined.extend_from_slice(&(p.len() as u32).to_be_bytes());
            combined.extend_from_slice(p);
        }

        let split = split_source_block(&combined);
        assert_eq!(split.len(), 3);
        assert_eq!(split[0], packets[0]);
        assert_eq!(split[1], packets[1]);
        assert_eq!(split[2], packets[2]);
    }

    // ── Gilbert–Elliott tests ──

    #[test]
    fn gilbert_elliott_starts_good() {
        let ge = GilbertElliott::new();
        assert!(!ge.is_bad());
        assert!((ge.fec_multiplier() - 1.0).abs() < 1e-6);
    }

    #[test]
    fn gilbert_elliott_transitions_to_bad() {
        let mut ge = GilbertElliott::with_thresholds(3, 5);
        // 3 consecutive losses → Bad
        ge.observe(false);
        assert!(!ge.is_bad());
        ge.observe(false);
        assert!(!ge.is_bad());
        ge.observe(false);
        assert!(ge.is_bad(), "3 consecutive losses should trigger Bad state");
        assert!((ge.fec_multiplier() - 2.0).abs() < 1e-6);
    }

    #[test]
    fn gilbert_elliott_recovers_to_good() {
        let mut ge = GilbertElliott::with_thresholds(2, 3);
        // Enter Bad state
        ge.observe(false);
        ge.observe(false);
        assert!(ge.is_bad());

        // 3 consecutive receives → Good
        ge.observe(true);
        ge.observe(true);
        assert!(ge.is_bad(), "Only 2 receives, not enough to recover");
        ge.observe(true);
        assert!(!ge.is_bad(), "3 receives should recover to Good state");
    }

    #[test]
    fn gilbert_elliott_mixed_resets_runs() {
        let mut ge = GilbertElliott::with_thresholds(3, 3);
        ge.observe(false);
        ge.observe(false);
        // Interrupted by a receive — bad_run resets
        ge.observe(true);
        ge.observe(false);
        ge.observe(false);
        assert!(
            !ge.is_bad(),
            "Interrupted loss run should not transition to Bad"
        );
    }

    #[test]
    fn protection_level_overhead_ratios() {
        assert!((ProtectionLevel::High.overhead_ratio() - 0.50).abs() < 1e-6);
        assert!((ProtectionLevel::Low.overhead_ratio() - 0.10).abs() < 1e-6);
        assert!((ProtectionLevel::None.overhead_ratio() - 0.0).abs() < 1e-6);
    }

    #[test]
    fn protection_level_changes_flush_old_block() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 8,
            high_overhead: 0.50,
            low_overhead: 0.10,
        };
        let mut enc = FecEncoder::new(cfg);

        // Start with High level
        enc.push(Bytes::from_static(b"hi1"), ProtectionLevel::High);
        enc.push(Bytes::from_static(b"hi2"), ProtectionLevel::High);

        // Switch to Low — should flush the partial High block
        let repairs = enc.push(Bytes::from_static(b"lo1"), ProtectionLevel::Low);
        assert!(
            !repairs.is_empty(),
            "Protection level change should flush previous block"
        );
        assert_eq!(enc.blocks_emitted(), 1);
    }

    #[test]
    fn set_overheads_scales_protection() {
        let cfg = FecConfig {
            enabled: true,
            source_block_size: 4,
            high_overhead: 0.50,
            low_overhead: 0.10,
        };
        let mut enc = FecEncoder::new(cfg);

        // Increase FEC overhead (simulating spare bandwidth)
        enc.set_overheads(0.40);

        // Low should now be 0.40 and High should be 1.0 (0.40 * 2.5 = 1.0)
        // Push 4 large packets at Low level — should produce more repair than default 10%
        let pkt_size = 3000;
        let mut repairs = Vec::new();
        for i in 0..4 {
            repairs.extend(enc.push(Bytes::from(vec![i; pkt_size]), ProtectionLevel::Low));
        }
        assert!(
            !repairs.is_empty(),
            "set_overheads at 40% should produce repair symbols for Low level"
        );

        // Compare against a default encoder at 10% Low
        let mut enc_default = FecEncoder::new(FecConfig {
            enabled: true,
            source_block_size: 4,
            high_overhead: 0.50,
            low_overhead: 0.10,
        });
        let mut default_repairs = Vec::new();
        for i in 0..4 {
            default_repairs
                .extend(enc_default.push(Bytes::from(vec![i; pkt_size]), ProtectionLevel::Low));
        }
        assert!(
            repairs.len() > default_repairs.len(),
            "40% overhead ({} repairs) should produce more repairs than 10% ({} repairs)",
            repairs.len(),
            default_repairs.len()
        );
    }
}
